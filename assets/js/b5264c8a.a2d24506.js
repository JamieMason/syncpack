"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[357],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>k});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),l=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=l(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),c=l(t),m=r,k=c["".concat(s,".").concat(m)]||c[m]||u[m]||i;return t?a.createElement(k,o(o({ref:n},d),{},{components:t})):a.createElement(k,o({ref:n},d))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p[c]="string"==typeof e?e:r,o[1]=p;for(var l=2;l<i;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9644:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>p,toc:()=>l});var a=t(7462),r=(t(7294),t(3905));const i={id:"version-groups",title:"versionGroups"},o=void 0,p={unversionedId:"config/version-groups",id:"config/version-groups",title:"versionGroups",description:"The most common use case for version groups is when some of the packages in your",source:"@site/docs/config/version-groups.md",sourceDirName:"config",slug:"/config/version-groups",permalink:"/syncpack/config/version-groups",draft:!1,editUrl:"https://github.com/JamieMason/syncpack/tree/master/site/docs/config/version-groups.md",tags:[],version:"current",lastUpdatedBy:"Jamie Mason",lastUpdatedAt:1676588726,formattedLastUpdatedAt:"Feb 16, 2023",frontMatter:{id:"version-groups",title:"versionGroups"},sidebar:"docs",previous:{title:"source",permalink:"/syncpack/config/source"}},s={},l=[{value:"versionGroup.dependencies",id:"versiongroupdependencies",level:2},{value:"versionGroup.packages",id:"versiongrouppackages",level:2},{value:"versionGroup.dependencyTypes",id:"versiongroupdependencytypes",level:2},{value:"versionGroup.isBanned",id:"versiongroupisbanned",level:2},{value:"versionGroup.isIgnored",id:"versiongroupisignored",level:2},{value:"versionGroup.pinVersion",id:"versiongrouppinversion",level:2}],d={toc:l},c="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The most common use case for version groups is when some of the packages in your\nMonorepo are considered alpha (or legacy). Since those packages are much further\nahead (or behind) the other packages, the dependencies within those packages\nneed to be managed differently to the rest of the Monorepo."),(0,r.kt)("p",null,"Your alpha packages might use unstable versions of some dependencies, while the\nrest of the repo might need to remain on stable versions."),(0,r.kt)("p",null,"You don't want mismatches within your alpha packages, you don't want mismatches\nwithin the other packages, but you ",(0,r.kt)("em",{parentName:"p"},"do")," want those groups to use different\nversions ",(0,r.kt)("em",{parentName:"p"},"to each other")," and not have ",(0,r.kt)("inlineCode",{parentName:"p"},"syncpack")," make them all the same."),(0,r.kt)("p",null,"In the following example, 2 of our packages are using different versions of\n",(0,r.kt)("inlineCode",{parentName:"p"},"react")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"react-dom")," to the rest of the project."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "versionGroups": [\n    {\n      "dependencies": ["react", "react-dom"],\n      "packages": ["@alpha/server", "@alpha/ui"]\n    }\n  ]\n}\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\ud83d\udc4b The ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"packages")," fields are processed using\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/isaacs/minimatch"},"minimatch"),", so the above example can\nalso be written as ",(0,r.kt)("inlineCode",{parentName:"p"},'"packages": ["@alpha/**"]'),".")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"syncpack")," will make ensure that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The versions of ",(0,r.kt)("inlineCode",{parentName:"li"},"react")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"react-dom")," are the same within ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/server"),"\nand ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/ui"),"."),(0,r.kt)("li",{parentName:"ul"},"The versions of ",(0,r.kt)("inlineCode",{parentName:"li"},"react")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"react-dom")," are the same across every package\nexcept ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/server")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/ui"),"."),(0,r.kt)("li",{parentName:"ul"},"The versions of ",(0,r.kt)("inlineCode",{parentName:"li"},"react")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"react-dom")," within ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/server")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/ui"),"\ncan be different to the other packages in the monorepo."),(0,r.kt)("li",{parentName:"ul"},"The versions of every other dependency in the monorepo (eg ",(0,r.kt)("inlineCode",{parentName:"li"},"lodash"),") are the\nsame across every package including ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/server")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@alpha/ui"),".")),(0,r.kt)("p",null,"Each dependency can only belong to one version group, the first rule which\nmatches a given dependency and package will apply."),(0,r.kt)("p",null,"You can be quite granular with these rules, so the partitioning doesn't ",(0,r.kt)("em",{parentName:"p"},"have"),"\nto apply to an entire package:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A specific dependency in a specific package."),(0,r.kt)("li",{parentName:"ul"},"A specific dependency in some specific packages only."),(0,r.kt)("li",{parentName:"ul"},"Any dependency who name matches a pattern such as ",(0,r.kt)("inlineCode",{parentName:"li"},"@aws-sdk/**"),".")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/syncpack/config/semver-groups"},(0,r.kt)("inlineCode",{parentName:"a"},"semverGroups"))," for more examples, they work the same\nway."),(0,r.kt)("h2",{id:"versiongroupdependencies"},"versionGroup.dependencies"),(0,r.kt)("p",null,"Required. An array of minimatch glob patterns which should match the key of\ndependencies defined in your package.json files."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Pattern"),(0,r.kt)("th",{parentName:"tr",align:null},"Matches"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["**"]')),(0,r.kt)("td",{parentName:"tr",align:null},"Any dependency")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["@aws-sdk/**"]')),(0,r.kt)("td",{parentName:"tr",align:null},"Any dependency with the scope ",(0,r.kt)("inlineCode",{parentName:"td"},"@aws-sdk"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["react", "react-dom"]')),(0,r.kt)("td",{parentName:"tr",align:null},"Specific dependencies by name")))),(0,r.kt)("h2",{id:"versiongrouppackages"},"versionGroup.packages"),(0,r.kt)("p",null,"Required. An array of minimatch glob patterns which should match the ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),"\nproperty of packages developed within your monorepo."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Pattern"),(0,r.kt)("th",{parentName:"tr",align:null},"Matches"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["**"]')),(0,r.kt)("td",{parentName:"tr",align:null},"Any package")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["@my-repo/**"]')),(0,r.kt)("td",{parentName:"tr",align:null},"Any package with the scope ",(0,r.kt)("inlineCode",{parentName:"td"},"@my-repo"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'["my-server", "my-client"]')),(0,r.kt)("td",{parentName:"tr",align:null},"Specific packages by name")))),(0,r.kt)("h2",{id:"versiongroupdependencytypes"},"versionGroup.dependencyTypes"),(0,r.kt)("p",null,"Optional. If set, will result in only the dependency types included in that\narray being considered a match for this version group."),(0,r.kt)("p",null,"In this example we define that all dependencies within ",(0,r.kt)("inlineCode",{parentName:"p"},"peerDependencies")," in the\nrepo must match, regardless of what versions of the same dependencies might be\nused in ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"devDependencies"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "versionGroups": [\n    {\n      "dependencies": ["**"],\n      "dependencyTypes": ["peerDependencies"],\n      "packages": ["**"]\n    }\n  ]\n}\n')),(0,r.kt)("h2",{id:"versiongroupisbanned"},"versionGroup.isBanned"),(0,r.kt)("p",null,"Remove dependencies which you've decided should never be allowed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "versionGroups": [\n    {\n      "dependencies": ["never-gonna"],\n      "isBanned": true,\n      "packages": ["**"]\n    }\n  ]\n}\n')),(0,r.kt)("h2",{id:"versiongroupisignored"},"versionGroup.isIgnored"),(0,r.kt)("p",null,"Have syncpack ignore these dependencies completely."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "versionGroups": [\n    {\n      "dependencies": ["**"],\n      "isIgnored": true,\n      "packages": ["oops-moment", "workaround"]\n    }\n  ]\n}\n')),(0,r.kt)("h2",{id:"versiongrouppinversion"},"versionGroup.pinVersion"),(0,r.kt)("p",null,"Pin the version of all dependencies in this group to match this specific version\nyou've defined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "versionGroups": [\n    {\n      "dependencies": ["@aws-sdk/**"],\n      "packages": ["**"],\n      "pinVersion": "3.55.0"\n    }\n  ]\n}\n')))}u.isMDXComponent=!0}}]);