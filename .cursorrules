# Syncpack Development Rules

Rust CLI tool for synchronizing npm dependency versions across monorepos.

## Critical Reading

Before any work, read:

1. `.notes/context.md` - Core concepts
2. `.notes/index.md` - Navigation hub
3. `.notes/plan-maintenance.md` - When working on plans
4. `.notes/documentation-website.md` - When contributing to docs site

## When to Ask vs Proceed

### Ask when

- User intent unclear or multiple valid approaches exist
- Breaking changes or core architecture modifications
- Creating ANY new files/modules not explicitly requested (including docs, notes, examples)
- Large refactors (ALWAYS ask strategy questions first)
- Architectural decisions: HashMap keys, error handling, etc.

### Proceed when

- Pattern clearly exists in codebase
- Following established convention
- Non-breaking changes
- Adding tests, fixing obvious bugs

### Large refactor rule

Before implementing, identify ALL decision points, document trade-offs, ask user to choose strategy. WAIT for answers.

## Core Architecture (NEVER BREAK)

### 3-Phase Pattern

Every command: Create Context → Inspect Context → Run Command

- Phase 1: Read CLI args → config → package.json → collect dependencies
- Phase 2: Assign InstanceState via visit_packages/visit_formatting
- Phase 3: Process instances, return exit code

### Ownership Rules

- Context owns all data (config, packages, instances, version_groups)
- Created once, passed through pipeline
- Each phase takes ownership, returns Context
- Commands consume Context, return exit code

### Key Invariants

1. **InstanceState assigned during inspection, NOT Context creation**
2. **Commands registered in 3 places:** Subcommand enum (cli.rs), match arm (main.rs), implementation (commands/\*.rs)
3. **Inspection is read-only:** visit_packages() tags only, file writes in command run()
4. **Use Rc for single-thread sharing:** `Rc::clone(&rc)` not `rc.clone()`. Arc only for cross-thread (RegistryClient)

### Wrong Patterns

❌ Assign InstanceState in Context::create | ✅ Assign in visit_packages
❌ Side effects in visit_packages | ✅ Side effects in command run()
❌ `rc.clone()` | ✅ `Rc::clone(&rc)`
❌ Chain `?` with intermediate vars | ✅ Fluent pipelines with .and_then()

## Communication Style

**Signal over noise** - applies to responses, plans, docs, comments:

- Extremely concise, fragments over sentences
- Action-oriented: what to DO
- Ground in facts: cite code/docs
- Remove: "basically", "essentially", "in order to"

## Code Style

- **Functional style preferred:** pipelines over loops
- **Avoid `?` chains:** use .and_then(), .map(), .or_else()
- **Descriptive names:** clarity over brevity in code
- **Single use statement:** group all imports in braces
- **Never use `super::`:** always `crate::` for internal imports
- **Named placeholders:** `println!("{var}")` not `println!("{}", var)`

### TDD Workflow (Mandatory)

1. Write failing test, verify it fails
2. Implement minimal code to pass
3. Check cargo/clippy
4. Refactor

### Code Quality

- Functions <50 lines, commands 100-300 lines
- Zero warnings (except during TDD red phase)
- No comments by default (only for complex logic)
- Scientific debugging: form hypotheses, test before fixing

### Testing

- **Integration tests:** Use TestBuilder in src/visit_packages/\*\_test.rs
- **Unit tests:** Vec of test scenarios, iterate and assert (see src/specifier2/\*\_test.rs)
- **Test naming:** `{behavior}_{condition}` or `{feature}_{scenario}`

### File Organization

- New command: src/commands/{name}.rs
- **New test: ALWAYS sibling \_test.rs file** (src/foo.rs → src/foo_test.rs)
- **NEVER use #[cfg(test)] modules inside implementation files**

### Import Style

```rust
use {
  crate::{cli::Cli, config::Config},
  log::{debug, error},
  std::{process::exit, sync::Arc},
};
```

### Documentation (Public Methods)

```rust
/// Brief description.
///
/// Examples:
/// - "input1" -> output1
/// - "input2" -> None
pub fn method_name(&self) -> ReturnType {}
```

## AI-Specific Rules

### Pre-Implementation Checklist

Before large changes:

- Have I identified ALL decision points?
- Have I listed trade-offs for each approach?
- Have I asked user which strategy to use?
- Am I making ANY architectural assumptions?
- Am I creating files user didn't request?

If "no" to ANY, STOP and ask.

### Recognizing Assumption Mode

STOP if you think:

- "I'll use approach X because it seems reasonable"
- "I can refactor later if wrong"
- "This is a minor detail"
- "I'll create helpful documentation"
- "I'll write a summary file"
- "Let me document this implementation"

Self-check: "Could this be done differently?" → Ask user
Self-check: "Am I creating a file user didn't request?" → STOP

### Code Search: MUST use ast-grep for .rs files

**Requirement:** Use `ast-grep` not `grep`/`rg` for Rust files (filters comments/strings/docs)

```bash
# Literal search
ast-grep -p 'Specifier::new' src/

# Pattern search
ast-grep -p 'pub struct $NAME' src/
ast-grep -p '$OBJ.$METHOD($$$)' src/
```

Use grep/rg ONLY for: multiple file types, intentionally searching comments, non-Rust files

### Before Making Claims

1. Search with ast-grep to verify
2. Read actual implementation
3. Base advice on verified facts

### Scope Boundaries (Off-Limits)

- Don't modify: Context creation, 3-phase pattern
- Don't refactor: Working commands unless requested
- Don't change: Public APIs (breaking)
- Don't add: Dependencies without discussion
- Don't remove: Tests
- Don't create: Files unless explicitly requested (NO docs, notes, examples, summaries)

## Design Rationale

**Why InstanceState in visit_packages?** Allows testing independently, enables Context reuse, clear phase separation

**Why Rc not Arc?** Single-threaded, Rc cheaper (no atomic ops). Arc only for RegistryClient (crosses threads)

**Why TestBuilder?** Ensures proper Context construction, prevents test shortcuts, maintainable

## Troubleshooting

### When stuck

1. Check `.notes/index.md` for right doc
2. Find similar code with ast-grep
3. Trace 3-phase pattern
4. Check test examples in src/visit_packages/\*\_test.rs

### Scientific debugging

1. Observe error carefully
2. Hypothesize root cause
3. Experiment with targeted changes, verify with ast-grep
4. Validate hypothesis
5. Fix and verify with tests

## Quick Reference

Before committing:

- ✅ Tests pass
- ✅ Zero clippy warnings
- ✅ No TODOs
- ✅ Patterns followed
- ✅ Only necessary changes

External docs: Use Context7 MCP (see `.notes/context7-guide.md`)
